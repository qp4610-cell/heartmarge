<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>í•˜íŠ¸ íŒ¡íŒ¡ - UI ê· í˜• ìµœì í™”ë³¸</title>
    <style>
        :root {
            --main-pink: #FF62A5;
            --dark-pink: #D1407A;
            --light-pink: #FFB6D3;
            --gauge-bg: #FFE6F0; 
            --pastel-bg: rgba(255, 235, 245, 0.25);
            --pastel-border: #FFD1E6;
            --btn-border: #FF8BBF;
            --yellow-fill: #FFED4D;
            --white: #FFFFFF;
        }

        body {
            margin: 0; padding: 0;
            background-color: #222;
            display: flex; justify-content: center; align-items: center;
            min-height: 100vh; min-height: 100dvh;
            overflow: hidden; touch-action: none;
        }

        #game-outer {
            width: 360px; height: 640px;
            background-image: url('bg.png');
            background-size: cover;
            display: flex; flex-direction: column;
            padding: 20px 15px; box-sizing: border-box;
            position: relative;
        }

        .header { display: flex; flex-direction: column; gap: 6px; margin-bottom: 15px; }
        .ui-row { display: flex; justify-content: space-between; align-items: center; }
        .gauge-wrapper { position: relative; display: flex; align-items: center; width: 82%; }
        
        .icon-img { position: absolute; left: -5px; width: 42px; height: 42px; z-index: 10; }
        
        .gauge-bar {
            width: 100%; height: 24px;
            background: var(--gauge-bg); 
            border: 2.5px solid var(--main-pink); border-radius: 20px; 
            margin-left: 18px;
            overflow: hidden; position: relative;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.05);
        }
        
        .gauge-fill { 
            height: 100%; 
            background: linear-gradient(to bottom, #FFED4D, #FFD700); 
            width: 100%; 
            transition: width 0.1s linear;
        }
        
        .score-text { 
            position: absolute; right: 12px; top: 50%; transform: translateY(-50%); 
            color: var(--main-pink); font-weight: 900; font-size: 1.1rem; 
            z-index: 5; 
            display: flex; align-items: baseline;
        }
        .score-text small {
            font-size: 0.8em;
            margin-left: 4px;
            font-weight: 700;
        }

        /* [ìˆ˜ì •] ë²„íŠ¼ ìœ„ì¹˜ë¥¼ ì•„ë˜ë¡œ ì‚´ì§ ë‚´ë ¤ ì •ë ¬ ìµœì í™” */
        #shuffle-btn { 
            background: none; 
            border: none; 
            cursor: pointer; 
            padding: 0; 
            margin-top: 8px; /* ìœ„ë¡œ ì¹˜ìš°ì¹œ í˜„ìƒ í•´ê²° */
        }
        #shuffle-btn img { width: 48px; height: 48px; }

        #canvas-wrapper {
            flex: 1; position: relative; width: 100%; 
            background: var(--pastel-bg);
            border-radius: 12px;
            border: 2.5px solid var(--pastel-border); 
            overflow: hidden;
        }
        canvas { width: 100%; height: 100%; display: block; }

        .modal { 
            position: absolute; top:0; left:0; width:100%; height:100%; 
            background: rgba(0,0,0,0.7); z-index: 100; 
            display: flex; flex-direction: column; justify-content: center; align-items: center; 
            padding: 40px; box-sizing: border-box;
        }
        .modal-content { 
            background: var(--white); border-radius: 30px; 
            padding: 30px 20px; text-align: center; width: 100%; max-width: 280px;
        }
        
        .modal h2 { color: var(--main-pink); font-size: 1.4rem; font-weight: 900; margin-bottom: 20px; }
        .tutorial-steps { text-align: left; font-size: 0.85rem; line-height: 2.2; color: #333; font-weight: 900; margin-bottom: 25px; }
        .tutorial-steps b { color: var(--main-pink); }

        .btn { 
            background: var(--main-pink); color: var(--white); 
            border: 2px solid var(--btn-border);
            padding: 14px 0; width: 100%; border-radius: 40px; 
            font-size: 1.3rem; font-weight: 900; cursor: pointer;
            box-shadow: 0 8px 0 var(--dark-pink);
            transition: all 0.1s;
        }
        .btn:active { transform: translateY(4px); box-shadow: 0 4px 0 var(--dark-pink); }

        #feedback-text {
            position: absolute; top: 45%; left: 50%; transform: translate(-50%, -50%);
            font-size: 4.5rem; font-weight: 900; color: var(--yellow-fill);
            -webkit-text-stroke: 8px var(--main-pink);
            paint-order: stroke fill;
            z-index: 50; pointer-events: none; opacity: 0;
        }
        @keyframes popUp {
            0% { opacity: 0; transform: translate(-50%, -30%) scale(0.5); }
            30% { opacity: 1; transform: translate(-50%, -60%) scale(1.1); }
            100% { opacity: 0; transform: translate(-50%, -100%) scale(0.8); }
        }
        .animate-pop { animation: popUp 0.7s ease-out forwards; }
        .hidden { display: none !important; }
    </style>
</head>
<body>

<div id="game-outer">
    <div class="header">
        <div class="ui-row">
            <div class="gauge-wrapper">
                <img src="watch.png" class="icon-img">
                <div class="gauge-bar"><div id="progress-fill" class="gauge-fill"></div></div>
            </div>
            <button id="shuffle-btn"><img src="refresh.png"></button>
        </div>
        <div class="ui-row">
            <div class="gauge-wrapper">
                <img src="heart.png" class="icon-img">
                <div class="gauge-bar">
                    <div class="score-text"><span id="score">0</span><small> POINT</small></div>
                    <div class="gauge-fill" style="width: 100%; opacity: 0.03;"></div>
                </div>
            </div>
        </div>
    </div>

    <div id="canvas-wrapper">
        <canvas id="gameCanvas"></canvas>
        <div id="feedback-text">Great!</div>
    </div>

    <div id="intro-modal" class="modal">
        <div class="modal-content">
            <h2>ğŸ’– í•˜íŠ¸ ê²Œì„ íŠœí† ë¦¬ì–¼</h2>
            <div class="tutorial-steps">
                â‘  í•˜íŠ¸ ìˆ«ì í•©ì´ <b>10</b>ì¸ ê³³ì„ ì°¾ìœ¼ì„¸ìš”.<br>
                â‘¡ <b>ì‚¬ê°í˜•</b>ì„ ê·¸ë¦¬ë“¯ ë“œë˜ê·¸í•˜ì—¬ ì„ íƒí•˜ì„¸ìš”.<br>
                â‘¢ í•©ì´ 10ì´ë©´ í•˜íŠ¸ê°€ íŒ¡! <b>ì ìˆ˜</b>ê°€ ì˜¬ë¼ê°€ìš”.<br>
                â‘£ ì—†ìœ¼ë©´ <b>ìƒˆë¡œê³ ì¹¨</b> ë²„íŠ¼ìœ¼ë¡œ ì¬ë°°ì—´í•˜ì„¸ìš”.
            </div>
            <button id="start-btn" class="btn" onclick="startGame()" ontouchend="startGame()">ê²Œì„ START!</button>
        </div>
    </div>

    <div id="result-modal" class="modal hidden">
        <div class="modal-content">
            <h2 style="font-size: 1.8rem; font-weight: 900;">GAME OVER</h2>
            <h1 id="final-score" style="font-size: 4rem; color: var(--main-pink); margin: 20px 0; font-weight: 900;">0</h1>
            <button class="btn" onclick="location.reload()" ontouchend="location.reload()">ë‹¤ì‹œ í•˜ê¸°</button>
        </div>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const dpr = window.devicePixelRatio || 1;
    const INT_W = 330; const INT_H = 490;
    canvas.width = INT_W * dpr; canvas.height = INT_H * dpr;
    ctx.scale(dpr, dpr);

    let images = {}; let imagesLoaded = 0;
    const assets = ['heart.png', 'watch.png', 'refresh.png', 'bg.png'];
    const startBtn = document.getElementById('start-btn');
    const feedbackText = document.getElementById('feedback-text');

    assets.forEach(src => {
        const img = new Image();
        img.onload = () => { imagesLoaded++; if(imagesLoaded === assets.length) { startBtn.innerText = "ê²Œì„ START!"; startBtn.disabled = false; } };
        img.src = src;
        images[src.split('.')[0]] = img;
    });

    let hearts = []; const ROWS = 17, COLS = 10;
    let score = 0, timeLeft = 60, isDragging = false;
    let startX, startY, currentX, currentY;
    let gameState = 'waiting';

    function initGame() {
        hearts = [];
        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                hearts.push({ row: r, col: c, val: Math.floor(Math.random() * 9) + 1, isAlive: true, isSelected: false });
            }
        }
        requestAnimationFrame(animate);
    }

    function startGame() {
        if(gameState !== 'waiting') return;
        gameState = 'playing'; timeLeft = 60; score = 0;
        document.getElementById('score').innerText = "0";
        document.getElementById('intro-modal').classList.add('hidden');
        initGame();
        
        const timer = setInterval(() => {
            if (gameState !== 'playing') {
                clearInterval(timer);
                return;
            }
            timeLeft -= 0.1;
            const progress = Math.max(0, (timeLeft / 60) * 100);
            document.getElementById('progress-fill').style.width = progress + '%';
            if (timeLeft <= 0) {
                clearInterval(timer);
                gameState = 'ended';
                document.getElementById('progress-fill').style.width = '0%';
                document.getElementById('final-score').innerText = score;
                document.getElementById('result-modal').classList.remove('hidden');
            }
        }, 100);
    }

    function animate() {
        ctx.clearRect(0, 0, INT_W, INT_H);
        const cellW = INT_W / COLS; const cellH = INT_H / ROWS;
        const heartSize = Math.min(cellW, cellH) * 0.92;
        const rx = Math.min(startX, currentX), ry = Math.min(startY, currentY);
        const rw = Math.abs(currentX - startX), rh = Math.abs(currentY - startY);

        hearts.forEach(h => {
            if (!h.isAlive) return;
            const hx = h.col * cellW + cellW/2; const hy = h.row * cellH + cellH/2;
            if (isDragging) {
                const half = heartSize / 2;
                h.isSelected = !(hx - half > rx + rw || hx + half < rx || hy - half > ry + rh || hy + half < ry);
            }
            ctx.save();
            if (h.isSelected && isDragging) {
                ctx.globalAlpha = 0.6; ctx.translate(hx, hy); ctx.scale(1.1, 1.1); ctx.translate(-hx, -hy);
            }
            if(images.heart) ctx.drawImage(images.heart, h.col * cellW + (cellW - heartSize)/2, h.row * cellH + (cellH - heartSize)/2, heartSize, heartSize);
            ctx.fillStyle = "white"; ctx.font = `900 ${heartSize * 0.55}px Arial`;
            ctx.textAlign = "center"; ctx.textBaseline = "middle";
            ctx.strokeStyle = "#FF62A5"; ctx.lineWidth = 1.5;
            ctx.strokeText(h.val, hx, hy + 2); ctx.fillText(h.val, hx, hy + 2); ctx.restore();
        });

        if (isDragging) {
            ctx.fillStyle = "rgba(255, 98, 165, 0.2)"; ctx.strokeStyle = "#FF62A5"; ctx.lineWidth = 3;
            ctx.fillRect(rx, ry, rw, rh); ctx.strokeRect(rx, ry, rw, rh);
        }
        requestAnimationFrame(animate);
    }

    function getPos(e) {
        const rect = canvas.getBoundingClientRect();
        const cx = (e.touches && e.touches.length > 0) ? e.touches[0].clientX : e.clientX;
        const cy = (e.touches && e.touches.length > 0) ? e.touches[0].clientY : e.clientY;
        return { x: (cx - rect.left) * (INT_W / rect.width), y: (cy - rect.top) * (INT_H / rect.height) };
    }

    const start = (e) => { if(gameState!=='playing') return; isDragging = true; const p = getPos(e); startX=p.x; startY=p.y; currentX=p.x; currentY=p.y; };
    const move = (e) => { if(!isDragging) return; const p = getPos(e); currentX=p.x; currentY=p.y; };
    const end = () => {
        if(!isDragging) return;
        let sum = 0; let selected = [];
        hearts.forEach(h => { if(h.isAlive && h.isSelected) { sum += h.val; selected.push(h); } });
        if(sum === 10) {
            score += 10; document.getElementById('score').innerText = score;
            selected.forEach(h => h.isAlive = false);
            feedbackText.classList.remove('animate-pop'); void feedbackText.offsetWidth; feedbackText.classList.add('animate-pop');
        }
        isDragging = false; hearts.forEach(h => h.isSelected = false);
    };

    canvas.addEventListener('mousedown', start); window.addEventListener('mousemove', move); window.addEventListener('mouseup', end);
    canvas.addEventListener('touchstart', e => { if(gameState === 'playing') e.preventDefault(); start(e); }, {passive: false});
    canvas.addEventListener('touchmove', e => { if(gameState === 'playing') e.preventDefault(); move(e); }, {passive: false});
    canvas.addEventListener('touchend', e => { if(gameState === 'playing') e.preventDefault(); end(); }, {passive: false});

    document.getElementById('shuffle-btn').onclick = () => {
        if(gameState === 'playing') hearts.forEach(h => { if(h.isAlive) h.val = Math.floor(Math.random()*9)+1; });
    };
</script>
</body>
</html>